# LLM-Aware Gateway æµ‹è¯•æŒ‡å—

> å®Œæ•´çš„æµ‹è¯•æ–¹æ³•å’Œæµ‹è¯•æ­¥éª¤æŒ‡å¯¼æ‰‹å†Œ

## ğŸ“‹ æµ‹è¯•æ¦‚è¿°

### æµ‹è¯•ç›®æ ‡
1. **åŠŸèƒ½æ­£ç¡®æ€§**ï¼šéªŒè¯å„æ¨¡å—åŠŸèƒ½ç¬¦åˆé¢„æœŸ
2. **æ€§èƒ½æŒ‡æ ‡**ï¼šç¡®ä¿æ»¡è¶³æ€§èƒ½è¦æ±‚ï¼ˆP95å»¶è¿Ÿâ‰¤2mså¢åŠ ï¼Œå‡ç¾æ•ˆæœâ‰¥40%ï¼‰
3. **ç¨³å®šæ€§éªŒè¯**ï¼šé•¿æ—¶é—´è¿è¡Œçš„ç¨³å®šæ€§
4. **å®¹é”™èƒ½åŠ›**ï¼šå¼‚å¸¸æƒ…å†µä¸‹çš„æ¢å¤èƒ½åŠ›
5. **æ‰©å±•æ€§æµ‹è¯•**ï¼šé«˜å¹¶å‘ä¸‹çš„æ‰©å±•èƒ½åŠ›

### æµ‹è¯•åˆ†å±‚ç­–ç•¥
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            ç«¯åˆ°ç«¯æµ‹è¯• (E2E)              â”‚  â† ä¸šåŠ¡æµç¨‹éªŒè¯
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚            é›†æˆæµ‹è¯• (Integration)        â”‚  â† ç»„ä»¶äº¤äº’éªŒè¯
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚            å•å…ƒæµ‹è¯• (Unit)               â”‚  â† å‡½æ•°çº§éªŒè¯
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ§ª å•å…ƒæµ‹è¯•

### æµ‹è¯•ç¯å¢ƒå‡†å¤‡

```bash
# 1. å®‰è£…æµ‹è¯•å·¥å…·
go install github.com/stretchr/testify/assert
go install github.com/golang/mock/mockgen

# 2. ç”ŸæˆMockå¯¹è±¡
mockgen -source=pkg/interfaces/*.go -destination=test/mocks/mock_interfaces.go

# 3. è¿è¡Œå•å…ƒæµ‹è¯•
make test
```

### æ ¸å¿ƒæ¨¡å—æµ‹è¯•

#### 1. é™æµå™¨æµ‹è¯•

```go
// test/unit/limiter_test.go
func TestClusterRateLimiter(t *testing.T) {
    tests := []struct {
        name           string
        baseRate       float64
        severity       float64
        requestCount   int
        expectedAllow  int
        description    string
    }{
        {
            name:          "æ­£å¸¸é™æµ",
            baseRate:      100,
            severity:      0.5,
            requestCount:  100,
            expectedAllow: 50, // 100 * (1 - 0.5) = 50
            description:   "50%ä¸¥é‡åº¦åº”è¯¥å…è®¸50ä¸ªè¯·æ±‚",
        },
        {
            name:          "é›¶ä¸¥é‡åº¦",
            baseRate:      100,
            severity:      0.0,
            requestCount:  100,
            expectedAllow: 100,
            description:   "0%ä¸¥é‡åº¦åº”è¯¥å…è®¸æ‰€æœ‰è¯·æ±‚",
        },
        {
            name:          "æœ€é«˜ä¸¥é‡åº¦",
            baseRate:      100,
            severity:      0.8,
            requestCount:  100,
            expectedAllow: 20, // 100 * (1 - 0.8) = 20
            description:   "80%ä¸¥é‡åº¦åº”è¯¥åªå…è®¸20ä¸ªè¯·æ±‚",
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            limiter := setupTestLimiter(tt.baseRate, tt.severity)

            allowedCount := 0
            for i := 0; i < tt.requestCount; i++ {
                ctx := createTestContext("test-cluster")
                if limiter.Allow(ctx) {
                    allowedCount++
                }
            }

            // å…è®¸5%çš„è¯¯å·®
            assert.InDelta(t, tt.expectedAllow, allowedCount, 5, tt.description)
        })
    }
}

func TestTokenBucket(t *testing.T) {
    t.Run("ä»¤ç‰Œæ¡¶åŸºæœ¬åŠŸèƒ½", func(t *testing.T) {
        bucket := NewTokenBucket(10, 10) // å®¹é‡10ï¼Œé€Ÿç‡10/s

        // åˆå§‹åº”è¯¥æœ‰æ»¡æ¡¶ä»¤ç‰Œ
        for i := 0; i < 10; i++ {
            assert.True(t, bucket.Allow())
        }

        // è¶…å‡ºå®¹é‡åº”è¯¥è¢«æ‹’ç»
        assert.False(t, bucket.Allow())

        // ç­‰å¾…1ç§’ï¼Œåº”è¯¥å¯ä»¥è·å¾—æ–°ä»¤ç‰Œ
        time.Sleep(1100 * time.Millisecond)
        assert.True(t, bucket.Allow())
    })
}
```

#### 2. ç†”æ–­å™¨æµ‹è¯•

```go
// test/unit/breaker_test.go
func TestCircuitBreaker(t *testing.T) {
    config := &types.BreakerConfig{
        FailureThreshold:  5,
        RecoveryTimeout:   time.Second,
        RecoveryIncrement: 0.2,
    }

    breaker := NewClusterCircuitBreaker(config)
    clusterID := "test-cluster"

    t.Run("ç†”æ–­å™¨çŠ¶æ€è½¬æ¢", func(t *testing.T) {
        // åˆå§‹çŠ¶æ€åº”è¯¥æ˜¯å…³é—­
        assert.Equal(t, types.BreakerStateClosed, breaker.GetState(clusterID))
        assert.True(t, breaker.Allow(context.Background(), clusterID))

        // è¿ç»­å¤±è´¥è¾¾åˆ°é˜ˆå€¼
        for i := 0; i < 5; i++ {
            breaker.RecordFailure(clusterID)
        }

        // åº”è¯¥è¿›å…¥å¼€å¯çŠ¶æ€
        assert.Equal(t, types.BreakerStateOpen, breaker.GetState(clusterID))
        assert.False(t, breaker.Allow(context.Background(), clusterID))

        // ç­‰å¾…æ¢å¤æ—¶é—´åè¿›å…¥åŠå¼€çŠ¶æ€
        time.Sleep(1100 * time.Millisecond)
        assert.Equal(t, types.BreakerStateHalfOpen, breaker.GetState(clusterID))
        assert.True(t, breaker.Allow(context.Background(), clusterID))

        // è®°å½•æˆåŠŸï¼Œåº”è¯¥å›åˆ°å…³é—­çŠ¶æ€
        breaker.RecordSuccess(clusterID)
        assert.Equal(t, types.BreakerStateClosed, breaker.GetState(clusterID))
    })
}
```

#### 3. èšç±»å¼•æ“æµ‹è¯•

```go
// test/unit/clustering_test.go
func TestClusteringEngine(t *testing.T) {
    t.Run("é”™è¯¯äº‹ä»¶èšç±»", func(t *testing.T) {
        mockEmbedding := &MockEmbeddingService{}
        mockVectorDB := &MockVectorDB{}
        config := &types.ClusteringConfig{
            SimilarityThreshold: 0.8,
            MaxClusters:        100,
        }

        engine := NewClusteringEngine(config, mockEmbedding, mockVectorDB)

        // Mockç›¸ä¼¼é”™è¯¯
        mockEmbedding.On("EmbedText", mock.AnythingOfType("string")).
            Return([]float32{1.0, 0.0, 0.0}, nil)

        event1 := &types.ErrorEvent{
            EventID:      "event-1",
            ServiceName:  "user-service",
            Method:       "POST",
            RequestPath:  "/api/users",
            ErrorMessage: "database connection failed",
            StackTrace:   []string{"at service.go:123", "at handler.go:456"},
        }

        event2 := &types.ErrorEvent{
            EventID:      "event-2",
            ServiceName:  "user-service",
            Method:       "POST",
            RequestPath:  "/api/users",
            ErrorMessage: "database connection timeout",
            StackTrace:   []string{"at service.go:124", "at handler.go:456"},
        }

        // å¤„ç†ç¬¬ä¸€ä¸ªäº‹ä»¶ï¼Œåº”è¯¥åˆ›å»ºæ–°ç°‡
        err := engine.ProcessErrorEvent(event1)
        assert.NoError(t, err)
        assert.NotEmpty(t, event1.ClusterID)

        clusterID := event1.ClusterID

        // å¤„ç†ç›¸ä¼¼äº‹ä»¶ï¼Œåº”è¯¥å½’å…¥åŒä¸€ç°‡
        err = engine.ProcessErrorEvent(event2)
        assert.NoError(t, err)
        assert.Equal(t, clusterID, event2.ClusterID)

        // éªŒè¯ç°‡çŠ¶æ€
        cluster, err := engine.GetCluster(clusterID)
        assert.NoError(t, err)
        assert.Equal(t, 2, cluster.ErrorCount)
        assert.Contains(t, cluster.Members, "event-1")
        assert.Contains(t, cluster.Members, "event-2")
    })
}
```

#### 4. å‘é‡æ•°æ®åº“æµ‹è¯•

```go
// test/unit/vectordb_test.go
func TestVectorDB(t *testing.T) {
    config := &types.VectorDBConfig{
        CacheSize: 1000,
        PostgreSQL: types.PostgreSQLConfig{
            Host:     "localhost",
            Port:     5432,
            Database: "test_db",
        },
    }

    vdb, err := NewVectorDB(config)
    assert.NoError(t, err)
    defer vdb.Close()

    t.Run("å‘é‡å­˜å‚¨å’Œæ£€ç´¢", func(t *testing.T) {
        vectors := map[string][]float32{
            "vec1": {1.0, 0.0, 0.0},
            "vec2": {0.0, 1.0, 0.0},
            "vec3": {0.0, 0.0, 1.0},
            "vec4": {0.7, 0.7, 0.0}, // ä¸vec1ç›¸ä¼¼
        }

        // å­˜å‚¨å‘é‡
        for id, vector := range vectors {
            err := vdb.AddVector(id, vector)
            assert.NoError(t, err)
        }

        // æœç´¢ç›¸ä¼¼å‘é‡
        query := []float32{0.9, 0.1, 0.0} // åº”è¯¥ä¸vec1æœ€ç›¸ä¼¼
        results, err := vdb.SearchSimilar(query, 2)
        assert.NoError(t, err)
        assert.Len(t, results, 2)
        assert.Equal(t, "vec1", results[0].ID) // æœ€ç›¸ä¼¼çš„åº”è¯¥æ˜¯vec1
    })
}
```

---

## ğŸ”— é›†æˆæµ‹è¯•

### æµ‹è¯•ç¯å¢ƒæ­å»º

```bash
# 1. å¯åŠ¨æµ‹è¯•ç¯å¢ƒ
make docker-compose-up

# 2. ç­‰å¾…æœåŠ¡å°±ç»ª
sleep 30

# 3. è¿è¡Œé›†æˆæµ‹è¯•
go test -tags=integration ./test/integration/... -v
```

### ç«¯åˆ°ç«¯æµç¨‹æµ‹è¯•

```go
// test/integration/e2e_test.go
//go:build integration
// +build integration

func TestErrorClusteringFlow(t *testing.T) {
    // å‡†å¤‡æµ‹è¯•ç¯å¢ƒ
    testEnv := setupIntegrationTestEnv(t)
    defer testEnv.Cleanup()

    t.Run("å®Œæ•´é”™è¯¯èšç±»æµç¨‹", func(t *testing.T) {
        // 1. å‘é€æ­£å¸¸è¯·æ±‚ï¼ŒéªŒè¯åŸºæœ¬åŠŸèƒ½
        resp := testEnv.SendRequest("GET", "/api/users", nil)
        assert.Equal(t, 200, resp.StatusCode)

        // 2. å‘é€ä¸€æ‰¹ç›¸ä¼¼é”™è¯¯è¯·æ±‚
        errorRequests := []TestRequest{
            {Method: "POST", Path: "/api/users", SimulateError: "database_connection"},
            {Method: "POST", Path: "/api/users", SimulateError: "database_connection"},
            {Method: "POST", Path: "/api/users", SimulateError: "database_connection"},
            {Method: "POST", Path: "/api/users", SimulateError: "database_connection"},
            {Method: "POST", Path: "/api/users", SimulateError: "database_connection"},
        }

        // å‘é€é”™è¯¯è¯·æ±‚
        for _, req := range errorRequests {
            resp := testEnv.SendRequest(req.Method, req.Path+"?error="+req.SimulateError, nil)
            assert.Equal(t, 500, resp.StatusCode)
        }

        // 3. ç­‰å¾…èšç±»å’Œç­–ç•¥ç”Ÿæˆ (æ¨¡æ‹Ÿå®é™…å¤„ç†æ—¶é—´)
        time.Sleep(30 * time.Second)

        // 4. éªŒè¯èšç±»ç»“æœ
        clusters, err := testEnv.GetClusters()
        assert.NoError(t, err)
        assert.Greater(t, len(clusters), 0, "åº”è¯¥è‡³å°‘æœ‰ä¸€ä¸ªé”™è¯¯ç°‡")

        // 5. éªŒè¯ç­–ç•¥ç”Ÿæ•ˆ - åç»­ç›¸åŒé”™è¯¯åº”è¯¥è¢«é™æµ
        limitedCount := 0
        for i := 0; i < 20; i++ {
            resp := testEnv.SendRequest("POST", "/api/users?error=database_connection", nil)
            if resp.StatusCode == 429 { // Too Many Requests
                limitedCount++
            }
        }

        assert.Greater(t, limitedCount, 5, "åº”è¯¥æœ‰éƒ¨åˆ†è¯·æ±‚è¢«é™æµ")

        // 6. éªŒè¯ç›‘æ§æŒ‡æ ‡
        metrics, err := testEnv.GetMetrics()
        assert.NoError(t, err)
        assert.Greater(t, metrics["gateway_requests_total"], 0)
        assert.Greater(t, metrics["gateway_rate_limit_hits_total"], 0)
    })
}

func TestCircuitBreakerFlow(t *testing.T) {
    testEnv := setupIntegrationTestEnv(t)
    defer testEnv.Cleanup()

    t.Run("ç†”æ–­å™¨æµç¨‹æµ‹è¯•", func(t *testing.T) {
        // 1. å¿«é€Ÿå‘é€å¤§é‡é”™è¯¯è¯·æ±‚è§¦å‘ç†”æ–­
        for i := 0; i < 50; i++ {
            testEnv.SendRequest("GET", "/api/service-down?error=service_unavailable", nil)
        }

        // ç­‰å¾…ç†”æ–­ç­–ç•¥ç”Ÿæˆ
        time.Sleep(20 * time.Second)

        // 2. éªŒè¯ç†”æ–­å™¨çŠ¶æ€
        stats, err := testEnv.GetClusterStats("service_unavailable_cluster")
        assert.NoError(t, err)
        assert.Equal(t, "open", stats.BreakerState) // åº”è¯¥å¤„äºå¼€å¯çŠ¶æ€

        // 3. éªŒè¯ç†”æ–­ç”Ÿæ•ˆ - è¯·æ±‚åº”è¯¥å¿«é€Ÿå¤±è´¥
        start := time.Now()
        resp := testEnv.SendRequest("GET", "/api/service-down", nil)
        duration := time.Since(start)

        assert.Equal(t, 503, resp.StatusCode) // Service Unavailable
        assert.Less(t, duration, 100*time.Millisecond, "ç†”æ–­è¯·æ±‚åº”è¯¥å¿«é€Ÿå¤±è´¥")

        // 4. ç­‰å¾…æ¢å¤æ—¶é—´åéªŒè¯åŠå¼€çŠ¶æ€
        time.Sleep(35 * time.Second) // è¶…è¿‡RecoveryTimeout

        stats, err = testEnv.GetClusterStats("service_unavailable_cluster")
        assert.NoError(t, err)
        assert.Equal(t, "half_open", stats.BreakerState)
    })
}
```

### é…ç½®çƒ­æ›´æ–°æµ‹è¯•

```go
func TestConfigHotReload(t *testing.T) {
    testEnv := setupIntegrationTestEnv(t)
    defer testEnv.Cleanup()

    t.Run("é…ç½®çƒ­æ›´æ–°", func(t *testing.T) {
        // 1. è·å–åˆå§‹é…ç½®
        initialConfig, err := testEnv.GetConfig()
        assert.NoError(t, err)

        // 2. æ›´æ–°ETCDä¸­çš„ç­–ç•¥é…ç½®
        newPolicy := &types.Policy{
            ClusterID:   "test-cluster",
            PolicyType:  types.PolicyTypeRateLimit,
            Severity:    0.8,
            RateLimit: &types.RateLimitPolicy{
                Rate:     50,
                Capacity: 100,
            },
            CreateTime: time.Now(),
            ExpireTime: time.Now().Add(1 * time.Hour),
        }

        err = testEnv.UpdatePolicy("test-cluster", newPolicy)
        assert.NoError(t, err)

        // 3. ç­‰å¾…é…ç½®æ›´æ–°ç”Ÿæ•ˆ
        time.Sleep(5 * time.Second)

        // 4. éªŒè¯æ–°é…ç½®å·²ç”Ÿæ•ˆ
        updatedConfig, err := testEnv.GetPolicy("test-cluster")
        assert.NoError(t, err)
        assert.Equal(t, newPolicy.Severity, updatedConfig.Severity)
        assert.Equal(t, newPolicy.RateLimit.Rate, updatedConfig.RateLimit.Rate)
    })
}
```

---

## âš¡ æ€§èƒ½æµ‹è¯•

### åŸºå‡†æµ‹è¯•

```bash
# 1. è¿è¡ŒåŸºå‡†æµ‹è¯•
make bench

# 2. ç”Ÿæˆæ€§èƒ½åˆ†ææŠ¥å‘Š
go test -bench=. -benchmem -cpuprofile=cpu.prof -memprofile=mem.prof ./...

# 3. åˆ†ææ€§èƒ½ç“¶é¢ˆ
go tool pprof cpu.prof
go tool pprof mem.prof
```

### å¹¶å‘æ€§èƒ½æµ‹è¯•

```go
// test/benchmark/gateway_benchmark_test.go
func BenchmarkGatewayThroughput(b *testing.B) {
    config := &types.GatewayConfig{
        Server: types.ServerConfig{Host: "localhost", Port: 8080},
        Limiter: types.LimiterConfig{DefaultRate: 100000}, // é«˜é™æµç”¨äºæµ‹è¯•
    }

    gateway, err := gateway.NewGateway(config)
    if err != nil {
        b.Fatal(err)
    }
    router := gateway.GetRouter()

    b.ResetTimer()
    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            w := httptest.NewRecorder()
            req := httptest.NewRequest("GET", "/api/test", nil)
            router.ServeHTTP(w, req)
        }
    })
}

func BenchmarkVectorSimilarity(b *testing.B) {
    vec1 := make([]float32, 768) // BGEæ¨¡å‹å‘é‡ç»´åº¦
    vec2 := make([]float32, 768)

    // åˆå§‹åŒ–å‘é‡
    for i := range vec1 {
        vec1[i] = rand.Float32()
        vec2[i] = rand.Float32()
    }

    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        _ = utils.CosineSimilarity(vec1, vec2)
    }
}

func BenchmarkClusteringEngine(b *testing.B) {
    mockEmbedding := &MockEmbeddingService{}
    mockVectorDB := &MockVectorDB{}
    config := &types.ClusteringConfig{SimilarityThreshold: 0.8}

    engine := NewClusteringEngine(config, mockEmbedding, mockVectorDB)

    // é¢„å¡«å……ä¸€äº›ç°‡
    for i := 0; i < 100; i++ {
        event := &types.ErrorEvent{
            EventID:      fmt.Sprintf("event-%d", i),
            ErrorMessage: fmt.Sprintf("error message %d", i%10), // 10ç§ä¸åŒé”™è¯¯
        }
        engine.ProcessErrorEvent(event)
    }

    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        event := &types.ErrorEvent{
            EventID:      fmt.Sprintf("bench-event-%d", i),
            ErrorMessage: "benchmark error message",
        }
        engine.ProcessErrorEvent(event)
    }
}
```

### å‹åŠ›æµ‹è¯•

```bash
#!/bin/bash
# test/stress/stress_test.sh

echo "å¼€å§‹å‹åŠ›æµ‹è¯•..."

# 1. å¯åŠ¨æµ‹è¯•ç¯å¢ƒ
make docker-compose-up
sleep 30

# 2. æ­£å¸¸æµé‡å‹åŠ›æµ‹è¯•
echo "=== æ­£å¸¸æµé‡å‹åŠ›æµ‹è¯• ==="
wrk -t12 -c400 -d30s --script=test/stress/normal_traffic.lua http://localhost:8080/api/test

# 3. é”™è¯¯æµé‡å‹åŠ›æµ‹è¯•
echo "=== é”™è¯¯æµé‡å‹åŠ›æµ‹è¯• ==="
wrk -t12 -c400 -d30s --script=test/stress/error_traffic.lua http://localhost:8080/api/test

# 4. æ··åˆæµé‡å‹åŠ›æµ‹è¯•
echo "=== æ··åˆæµé‡å‹åŠ›æµ‹è¯• ==="
wrk -t12 -c400 -d60s --script=test/stress/mixed_traffic.lua http://localhost:8080/api/test

# 5. æ”¶é›†æ€§èƒ½æŒ‡æ ‡
echo "=== æ€§èƒ½æŒ‡æ ‡æ”¶é›† ==="
curl -s http://localhost:8080/metrics | grep -E "(request_duration|rate_limit_hits|cluster_size)"

# 6. æ¸…ç†ç¯å¢ƒ
make docker-compose-down
```

### æ€§èƒ½éªŒæ”¶æ ‡å‡†

```go
// test/performance/acceptance_test.go
func TestPerformanceAcceptance(t *testing.T) {
    testEnv := setupPerformanceTestEnv(t)
    defer testEnv.Cleanup()

    t.Run("å»¶è¿Ÿå¢åŠ éªŒæ”¶", func(t *testing.T) {
        // æµ‹è¯•æ— ç½‘å…³ç›´è¿å»¶è¿Ÿ
        baselineLatency := measureDirectLatency(t, 1000)

        // æµ‹è¯•é€šè¿‡ç½‘å…³å»¶è¿Ÿ
        gatewayLatency := measureGatewayLatency(t, 1000)

        // éªŒæ”¶æ ‡å‡†ï¼šP95å»¶è¿Ÿå¢åŠ â‰¤2ms
        latencyIncrease := gatewayLatency.P95 - baselineLatency.P95
        assert.LessOrEqual(t, latencyIncrease, 2*time.Millisecond,
            "P95å»¶è¿Ÿå¢åŠ åº”è¯¥â‰¤2msï¼Œå®é™…å¢åŠ äº†%.2fms",
            float64(latencyIncrease)/float64(time.Millisecond))
    })

    t.Run("å‡ç¾æ•ˆæœéªŒæ”¶", func(t *testing.T) {
        // æ¨¡æ‹Ÿæ•…éšœåœºæ™¯
        faultScenario := &FaultInjection{
            ErrorRate:    0.5, // 50%é”™è¯¯ç‡
            Duration:     60 * time.Second,
            ErrorType:    "database_timeout",
        }

        // æ— ä¿æŠ¤æƒ…å†µä¸‹çš„é”™è¯¯å³°å€¼
        baselineErrors := measureErrorsWithoutProtection(t, faultScenario)

        // æœ‰ä¿æŠ¤æƒ…å†µä¸‹çš„é”™è¯¯å³°å€¼
        protectedErrors := measureErrorsWithProtection(t, faultScenario)

        // éªŒæ”¶æ ‡å‡†ï¼šå‡ç¾æ•ˆæœâ‰¥40%
        reductionRate := (baselineErrors - protectedErrors) / baselineErrors
        assert.GreaterOrEqual(t, reductionRate, 0.4,
            "å‡ç¾æ•ˆæœåº”è¯¥â‰¥40%%ï¼Œå®é™…ä¸º%.1f%%", reductionRate*100)
    })

    t.Run("è¯¯æ€ç‡éªŒæ”¶", func(t *testing.T) {
        // åœ¨é™æµç­–ç•¥ç”Ÿæ•ˆæœŸé—´å‘é€æ­£å¸¸è¯·æ±‚
        totalRequests := 1000
        successfulRequests := 0
        rateLimitedRequests := 0

        for i := 0; i < totalRequests; i++ {
            resp := testEnv.SendNormalRequest()
            switch resp.StatusCode {
            case 200:
                successfulRequests++
            case 429:
                rateLimitedRequests++
                // éªŒè¯è¢«é™æµçš„è¯·æ±‚å¦‚æœé‡è¯•æ˜¯å¦èƒ½æˆåŠŸ
                retryResp := testEnv.RetryRequest(resp.Headers["Retry-After"])
                if retryResp.StatusCode == 200 {
                    // è¿™ç®—ä½œè¯¯æ€
                }
            }
        }

        // éªŒæ”¶æ ‡å‡†ï¼šè¯¯æ€ç‡â‰¤2%
        falsePositiveRate := float64(rateLimitedRequests) / float64(totalRequests)
        assert.LessOrEqual(t, falsePositiveRate, 0.02,
            "è¯¯æ€ç‡åº”è¯¥â‰¤2%%ï¼Œå®é™…ä¸º%.1f%%", falsePositiveRate*100)
    })
}
```

---

## ğŸ¥ å¥åº·æ£€æŸ¥å’Œç›‘æ§æµ‹è¯•

### å¥åº·æ£€æŸ¥æµ‹è¯•

```go
// test/health/health_test.go
func TestHealthEndpoints(t *testing.T) {
    testEnv := setupTestEnv(t)
    defer testEnv.Cleanup()

    t.Run("å¥åº·æ£€æŸ¥", func(t *testing.T) {
        resp, err := http.Get("http://localhost:8080/health")
        assert.NoError(t, err)
        assert.Equal(t, 200, resp.StatusCode)

        var health map[string]interface{}
        json.NewDecoder(resp.Body).Decode(&health)
        assert.Equal(t, "healthy", health["status"])
    })

    t.Run("å°±ç»ªæ£€æŸ¥", func(t *testing.T) {
        resp, err := http.Get("http://localhost:8080/ready")
        assert.NoError(t, err)
        assert.Contains(t, []int{200, 503}, resp.StatusCode)

        var readiness map[string]interface{}
        json.NewDecoder(resp.Body).Decode(&readiness)
        assert.NotEmpty(t, readiness["components"])
    })
}
```

### ç›‘æ§æŒ‡æ ‡æµ‹è¯•

```go
func TestMonitoringMetrics(t *testing.T) {
    testEnv := setupTestEnv(t)
    defer testEnv.Cleanup()

    t.Run("PrometheusæŒ‡æ ‡", func(t *testing.T) {
        // å‘é€ä¸€äº›è¯·æ±‚äº§ç”ŸæŒ‡æ ‡
        for i := 0; i < 100; i++ {
            testEnv.SendRequest("GET", "/api/test", nil)
        }

        // è·å–æŒ‡æ ‡
        resp, err := http.Get("http://localhost:8080/metrics")
        assert.NoError(t, err)

        body, err := io.ReadAll(resp.Body)
        assert.NoError(t, err)
        metrics := string(body)

        // éªŒè¯å…³é”®æŒ‡æ ‡å­˜åœ¨
        assert.Contains(t, metrics, "gateway_requests_total")
        assert.Contains(t, metrics, "gateway_request_duration_seconds")
        assert.Contains(t, metrics, "gateway_rate_limit_hits_total")
        assert.Contains(t, metrics, "gateway_circuit_breaker_state")
    })
}
```

---

## ğŸ“Š æµ‹è¯•æ•°æ®å’Œåœºæ™¯

### æµ‹è¯•æ•°æ®å‡†å¤‡

```go
// test/testdata/scenarios.go
var TestScenarios = []struct {
    Name        string
    Description string
    Requests    []TestRequest
    Expected    TestExpectation
}{
    {
        Name:        "æ•°æ®åº“è¿æ¥é”™è¯¯èšç±»",
        Description: "ç›¸ä¼¼çš„æ•°æ®åº“è¿æ¥é”™è¯¯åº”è¯¥è¢«èšç±»åˆ°åŒä¸€ç°‡",
        Requests: []TestRequest{
            {Path: "/api/users", Error: "connection timeout to database"},
            {Path: "/api/orders", Error: "database connection failed"},
            {Path: "/api/products", Error: "timeout connecting to database"},
        },
        Expected: TestExpectation{
            ClusterCount:    1,
            ShouldTrigger:   true,
            PolicyType:     "rate_limit",
            ExpectedSeverity: 0.6,
        },
    },
    {
        Name:        "ä¸åŒç±»å‹é”™è¯¯åˆ†ç¦»",
        Description: "ä¸åŒç±»å‹çš„é”™è¯¯åº”è¯¥è¢«åˆ†åˆ°ä¸åŒç°‡",
        Requests: []TestRequest{
            {Path: "/api/users", Error: "database connection failed"},
            {Path: "/api/users", Error: "authentication required"},
            {Path: "/api/users", Error: "invalid request format"},
        },
        Expected: TestExpectation{
            ClusterCount:  3,
            ShouldTrigger: false,
        },
    },
}
```

### é”™è¯¯æ³¨å…¥æµ‹è¯•

```go
// test/chaos/fault_injection_test.go
func TestFaultInjection(t *testing.T) {
    testEnv := setupChaosTestEnv(t)
    defer testEnv.Cleanup()

    faults := []ChaosTest{
        {
            Name:     "æ•°æ®åº“æ•…éšœ",
            Fault:    &DatabaseDownFault{Duration: 30 * time.Second},
            Expected: &ExpectedBehavior{ShouldCircuitBreak: true},
        },
        {
            Name:     "ç½‘ç»œå»¶è¿Ÿ",
            Fault:    &NetworkLatencyFault{Latency: 5 * time.Second},
            Expected: &ExpectedBehavior{ShouldRateLimit: true},
        },
        {
            Name:     "å†…å­˜ä¸è¶³",
            Fault:    &MemoryExhaustionFault{},
            Expected: &ExpectedBehavior{ShouldGracefullyDegrade: true},
        },
    }

    for _, fault := range faults {
        t.Run(fault.Name, func(t *testing.T) {
            // æ³¨å…¥æ•…éšœ
            testEnv.InjectFault(fault.Fault)

            // å‘é€æµé‡
            results := testEnv.SendTrafficDuringFault(1000)

            // éªŒè¯é¢„æœŸè¡Œä¸º
            testEnv.VerifyBehavior(results, fault.Expected)

            // æ¸…ç†æ•…éšœ
            testEnv.ClearFault(fault.Fault)
        })
    }
}
```

---

## ğŸš€ æµ‹è¯•æ‰§è¡Œæµç¨‹

### æœ¬åœ°æµ‹è¯•æµç¨‹

```bash
#!/bin/bash
# æœ¬åœ°å®Œæ•´æµ‹è¯•æµç¨‹

echo "ğŸš€ å¼€å§‹LLM-Aware Gatewayæµ‹è¯•æµç¨‹"

# 1. ç¯å¢ƒæ£€æŸ¥
echo "ğŸ“‹ ç¯å¢ƒæ£€æŸ¥..."
go version
docker --version
make --version

# 2. ä¾èµ–å®‰è£…
echo "ğŸ“¦ å®‰è£…ä¾èµ–..."
make deps
make install-tools

# 3. ä»£ç è´¨é‡æ£€æŸ¥
echo "ğŸ” ä»£ç è´¨é‡æ£€æŸ¥..."
make fmt
make vet
make lint

# 4. å•å…ƒæµ‹è¯•
echo "ğŸ§ª å•å…ƒæµ‹è¯•..."
make test

# 5. å¯åŠ¨æµ‹è¯•ç¯å¢ƒ
echo "ğŸ³ å¯åŠ¨æµ‹è¯•ç¯å¢ƒ..."
make docker-compose-up
sleep 30

# 6. å¥åº·æ£€æŸ¥
echo "ğŸ’“ å¥åº·æ£€æŸ¥..."
make health-check

# 7. é›†æˆæµ‹è¯•
echo "ğŸ”— é›†æˆæµ‹è¯•..."
go test -tags=integration ./test/integration/... -v

# 8. æ€§èƒ½æµ‹è¯•
echo "âš¡ æ€§èƒ½æµ‹è¯•..."
go test -bench=. ./test/benchmark/... -v

# 9. å‹åŠ›æµ‹è¯•
echo "ğŸ’ª å‹åŠ›æµ‹è¯•..."
bash test/stress/stress_test.sh

# 10. æ¸…ç†ç¯å¢ƒ
echo "ğŸ§¹ æ¸…ç†ç¯å¢ƒ..."
make docker-compose-down

echo "âœ… æµ‹è¯•æµç¨‹å®Œæˆï¼"
```

### CI/CDæµ‹è¯•æµç¨‹

```yaml
# .github/workflows/test.yml
name: Test Pipeline

on: [push, pull_request]

jobs:
  unit-test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - uses: actions/setup-go@v3
      with:
        go-version: '1.21'

    - name: Run unit tests
      run: |
        make deps
        make test

    - name: Upload coverage
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.out

  integration-test:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: password
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

      etcd:
        image: quay.io/coreos/etcd:v3.5.10

    steps:
    - uses: actions/checkout@v3
    - uses: actions/setup-go@v3
      with:
        go-version: '1.21'

    - name: Start test environment
      run: make docker-compose-up

    - name: Run integration tests
      run: go test -tags=integration ./test/integration/... -v

    - name: Cleanup
      run: make docker-compose-down

  performance-test:
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
    - uses: actions/checkout@v3
    - name: Run performance tests
      run: |
        make docker-compose-up
        sleep 30
        bash test/performance/run_performance_tests.sh
        make docker-compose-down
```

---

## ğŸ“ˆ æµ‹è¯•æŠ¥å‘Šå’Œåˆ†æ

### æµ‹è¯•è¦†ç›–ç‡è¦æ±‚

- **å•å…ƒæµ‹è¯•è¦†ç›–ç‡**: â‰¥80%
- **é›†æˆæµ‹è¯•è¦†ç›–ç‡**: â‰¥60%
- **å…³é”®è·¯å¾„è¦†ç›–ç‡**: 100%

### æ€§èƒ½åŸºçº¿

| æŒ‡æ ‡ | ç›®æ ‡å€¼ | æµ‹è¯•æ–¹æ³• |
|------|--------|----------|
| P95å»¶è¿Ÿå¢åŠ  | â‰¤2ms | åŸºå‡†å¯¹æ¯”æµ‹è¯• |
| ååé‡æŸå¤± | â‰¤5% | å‹åŠ›æµ‹è¯• |
| å†…å­˜ä½¿ç”¨å¢åŠ  | â‰¤50MB | é•¿æ—¶é—´è¿è¡Œæµ‹è¯• |
| CPUä½¿ç”¨å¢åŠ  | â‰¤10% | è´Ÿè½½æµ‹è¯• |
| å‡ç¾æ•ˆæœ | â‰¥40% | æ•…éšœæ³¨å…¥æµ‹è¯• |
| è¯¯æ€ç‡ | â‰¤2% | æ··åˆæµé‡æµ‹è¯• |

### æµ‹è¯•æŠ¥å‘Šæ¨¡æ¿

```markdown
# æµ‹è¯•æŠ¥å‘Š

## æµ‹è¯•æ¦‚å†µ
- æµ‹è¯•æ—¶é—´ï¼š2024-01-15
- æµ‹è¯•ç¯å¢ƒï¼šDocker Compose
- æµ‹è¯•ç‰ˆæœ¬ï¼šv1.0.0

## æµ‹è¯•ç»“æœæ‘˜è¦
- âœ… å•å…ƒæµ‹è¯•ï¼šé€šè¿‡ç‡ 98%ï¼ˆ196/200ï¼‰
- âœ… é›†æˆæµ‹è¯•ï¼šé€šè¿‡ç‡ 95%ï¼ˆ38/40ï¼‰
- âœ… æ€§èƒ½æµ‹è¯•ï¼šè¾¾æ ‡ï¼ˆP95å»¶è¿Ÿå¢åŠ 1.8msï¼‰
- âš ï¸ å‹åŠ›æµ‹è¯•ï¼šéƒ¨åˆ†è¾¾æ ‡ï¼ˆéœ€ä¼˜åŒ–å†…å­˜ä½¿ç”¨ï¼‰

## è¯¦ç»†ç»“æœ
### åŠŸèƒ½æµ‹è¯•
- é™æµå™¨ï¼šâœ… é€šè¿‡
- ç†”æ–­å™¨ï¼šâœ… é€šè¿‡
- èšç±»å¼•æ“ï¼šâœ… é€šè¿‡
- é…ç½®çƒ­æ›´æ–°ï¼šâœ… é€šè¿‡

### æ€§èƒ½æµ‹è¯•
- å»¶è¿Ÿå¢åŠ ï¼š1.8msï¼ˆç›®æ ‡â‰¤2msï¼‰âœ…
- å‡ç¾æ•ˆæœï¼š42%ï¼ˆç›®æ ‡â‰¥40%ï¼‰âœ…
- è¯¯æ€ç‡ï¼š1.8%ï¼ˆç›®æ ‡â‰¤2%ï¼‰âœ…

## é—®é¢˜å’Œå»ºè®®
1. å†…å­˜ä½¿ç”¨åœ¨é«˜è´Ÿè½½ä¸‹è¶…å‡ºé¢„æœŸï¼Œå»ºè®®ä¼˜åŒ–ç¼“å­˜ç­–ç•¥
2. æŸäº›è¾¹ç•Œæ¡ä»¶ä¸‹çš„é”™è¯¯å¤„ç†éœ€è¦å®Œå–„

## é£é™©è¯„ä¼°
- ä½é£é™©ï¼šæ ¸å¿ƒåŠŸèƒ½ç¨³å®šå¯é 
- ä¸­é£é™©ï¼šé«˜å¹¶å‘åœºæ™¯ä¸‹éœ€è¦ç›‘æ§å†…å­˜ä½¿ç”¨

## å‘å¸ƒå»ºè®®
âœ… å»ºè®®å‘å¸ƒåˆ°ç”Ÿäº§ç¯å¢ƒï¼Œå»ºè®®å¢åŠ å†…å­˜ç›‘æ§å‘Šè­¦
```

è¿™ä¸ªæµ‹è¯•æŒ‡å—æ¶µç›–äº†ä»å•å…ƒæµ‹è¯•åˆ°æ€§èƒ½æµ‹è¯•çš„å®Œæ•´æµ‹è¯•ç­–ç•¥ï¼Œç¡®ä¿LLM-Aware Gatewayçš„è´¨é‡å’Œå¯é æ€§ã€‚é€šè¿‡ç³»ç»ŸåŒ–çš„æµ‹è¯•æ–¹æ³•ï¼Œå¯ä»¥éªŒè¯ç³»ç»Ÿåœ¨å„ç§åœºæ™¯ä¸‹çš„è¡¨ç°ï¼Œä¸ºç”Ÿäº§ç¯å¢ƒéƒ¨ç½²æä¾›ä¿¡å¿ƒã€‚
