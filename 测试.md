# LLM-Aware Gateway 测试指南

> 完整的测试方法和测试步骤指导手册

## 📋 测试概述

### 测试目标
1. **功能正确性**：验证各模块功能符合预期
2. **性能指标**：确保满足性能要求（P95延迟≤2ms增加，减灾效果≥40%）
3. **稳定性验证**：长时间运行的稳定性
4. **容错能力**：异常情况下的恢复能力
5. **扩展性测试**：高并发下的扩展能力

### 测试分层策略
```
┌─────────────────────────────────────────┐
│            端到端测试 (E2E)              │  ← 业务流程验证
├─────────────────────────────────────────┤
│            集成测试 (Integration)        │  ← 组件交互验证
├─────────────────────────────────────────┤
│            单元测试 (Unit)               │  ← 函数级验证
└─────────────────────────────────────────┘
```

---

## 🧪 单元测试

### 测试环境准备

```bash
# 1. 安装测试工具
go install github.com/stretchr/testify/assert
go install github.com/golang/mock/mockgen

# 2. 生成Mock对象
mockgen -source=pkg/interfaces/*.go -destination=test/mocks/mock_interfaces.go

# 3. 运行单元测试
make test
```

### 核心模块测试

#### 1. 限流器测试

```go
// test/unit/limiter_test.go
func TestClusterRateLimiter(t *testing.T) {
    tests := []struct {
        name           string
        baseRate       float64
        severity       float64
        requestCount   int
        expectedAllow  int
        description    string
    }{
        {
            name:          "正常限流",
            baseRate:      100,
            severity:      0.5,
            requestCount:  100,
            expectedAllow: 50, // 100 * (1 - 0.5) = 50
            description:   "50%严重度应该允许50个请求",
        },
        {
            name:          "零严重度",
            baseRate:      100,
            severity:      0.0,
            requestCount:  100,
            expectedAllow: 100,
            description:   "0%严重度应该允许所有请求",
        },
        {
            name:          "最高严重度",
            baseRate:      100,
            severity:      0.8,
            requestCount:  100,
            expectedAllow: 20, // 100 * (1 - 0.8) = 20
            description:   "80%严重度应该只允许20个请求",
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            limiter := setupTestLimiter(tt.baseRate, tt.severity)

            allowedCount := 0
            for i := 0; i < tt.requestCount; i++ {
                ctx := createTestContext("test-cluster")
                if limiter.Allow(ctx) {
                    allowedCount++
                }
            }

            // 允许5%的误差
            assert.InDelta(t, tt.expectedAllow, allowedCount, 5, tt.description)
        })
    }
}

func TestTokenBucket(t *testing.T) {
    t.Run("令牌桶基本功能", func(t *testing.T) {
        bucket := NewTokenBucket(10, 10) // 容量10，速率10/s

        // 初始应该有满桶令牌
        for i := 0; i < 10; i++ {
            assert.True(t, bucket.Allow())
        }

        // 超出容量应该被拒绝
        assert.False(t, bucket.Allow())

        // 等待1秒，应该可以获得新令牌
        time.Sleep(1100 * time.Millisecond)
        assert.True(t, bucket.Allow())
    })
}
```

#### 2. 熔断器测试

```go
// test/unit/breaker_test.go
func TestCircuitBreaker(t *testing.T) {
    config := &types.BreakerConfig{
        FailureThreshold:  5,
        RecoveryTimeout:   time.Second,
        RecoveryIncrement: 0.2,
    }

    breaker := NewClusterCircuitBreaker(config)
    clusterID := "test-cluster"

    t.Run("熔断器状态转换", func(t *testing.T) {
        // 初始状态应该是关闭
        assert.Equal(t, types.BreakerStateClosed, breaker.GetState(clusterID))
        assert.True(t, breaker.Allow(context.Background(), clusterID))

        // 连续失败达到阈值
        for i := 0; i < 5; i++ {
            breaker.RecordFailure(clusterID)
        }

        // 应该进入开启状态
        assert.Equal(t, types.BreakerStateOpen, breaker.GetState(clusterID))
        assert.False(t, breaker.Allow(context.Background(), clusterID))

        // 等待恢复时间后进入半开状态
        time.Sleep(1100 * time.Millisecond)
        assert.Equal(t, types.BreakerStateHalfOpen, breaker.GetState(clusterID))
        assert.True(t, breaker.Allow(context.Background(), clusterID))

        // 记录成功，应该回到关闭状态
        breaker.RecordSuccess(clusterID)
        assert.Equal(t, types.BreakerStateClosed, breaker.GetState(clusterID))
    })
}
```

#### 3. 聚类引擎测试

```go
// test/unit/clustering_test.go
func TestClusteringEngine(t *testing.T) {
    t.Run("错误事件聚类", func(t *testing.T) {
        mockEmbedding := &MockEmbeddingService{}
        mockVectorDB := &MockVectorDB{}
        config := &types.ClusteringConfig{
            SimilarityThreshold: 0.8,
            MaxClusters:        100,
        }

        engine := NewClusteringEngine(config, mockEmbedding, mockVectorDB)

        // Mock相似错误
        mockEmbedding.On("EmbedText", mock.AnythingOfType("string")).
            Return([]float32{1.0, 0.0, 0.0}, nil)

        event1 := &types.ErrorEvent{
            EventID:      "event-1",
            ServiceName:  "user-service",
            Method:       "POST",
            RequestPath:  "/api/users",
            ErrorMessage: "database connection failed",
            StackTrace:   []string{"at service.go:123", "at handler.go:456"},
        }

        event2 := &types.ErrorEvent{
            EventID:      "event-2",
            ServiceName:  "user-service",
            Method:       "POST",
            RequestPath:  "/api/users",
            ErrorMessage: "database connection timeout",
            StackTrace:   []string{"at service.go:124", "at handler.go:456"},
        }

        // 处理第一个事件，应该创建新簇
        err := engine.ProcessErrorEvent(event1)
        assert.NoError(t, err)
        assert.NotEmpty(t, event1.ClusterID)

        clusterID := event1.ClusterID

        // 处理相似事件，应该归入同一簇
        err = engine.ProcessErrorEvent(event2)
        assert.NoError(t, err)
        assert.Equal(t, clusterID, event2.ClusterID)

        // 验证簇状态
        cluster, err := engine.GetCluster(clusterID)
        assert.NoError(t, err)
        assert.Equal(t, 2, cluster.ErrorCount)
        assert.Contains(t, cluster.Members, "event-1")
        assert.Contains(t, cluster.Members, "event-2")
    })
}
```

#### 4. 向量数据库测试

```go
// test/unit/vectordb_test.go
func TestVectorDB(t *testing.T) {
    config := &types.VectorDBConfig{
        CacheSize: 1000,
        PostgreSQL: types.PostgreSQLConfig{
            Host:     "localhost",
            Port:     5432,
            Database: "test_db",
        },
    }

    vdb, err := NewVectorDB(config)
    assert.NoError(t, err)
    defer vdb.Close()

    t.Run("向量存储和检索", func(t *testing.T) {
        vectors := map[string][]float32{
            "vec1": {1.0, 0.0, 0.0},
            "vec2": {0.0, 1.0, 0.0},
            "vec3": {0.0, 0.0, 1.0},
            "vec4": {0.7, 0.7, 0.0}, // 与vec1相似
        }

        // 存储向量
        for id, vector := range vectors {
            err := vdb.AddVector(id, vector)
            assert.NoError(t, err)
        }

        // 搜索相似向量
        query := []float32{0.9, 0.1, 0.0} // 应该与vec1最相似
        results, err := vdb.SearchSimilar(query, 2)
        assert.NoError(t, err)
        assert.Len(t, results, 2)
        assert.Equal(t, "vec1", results[0].ID) // 最相似的应该是vec1
    })
}
```

---

## 🔗 集成测试

### 测试环境搭建

```bash
# 1. 启动测试环境
make docker-compose-up

# 2. 等待服务就绪
sleep 30

# 3. 运行集成测试
go test -tags=integration ./test/integration/... -v
```

### 端到端流程测试

```go
// test/integration/e2e_test.go
//go:build integration
// +build integration

func TestErrorClusteringFlow(t *testing.T) {
    // 准备测试环境
    testEnv := setupIntegrationTestEnv(t)
    defer testEnv.Cleanup()

    t.Run("完整错误聚类流程", func(t *testing.T) {
        // 1. 发送正常请求，验证基本功能
        resp := testEnv.SendRequest("GET", "/api/users", nil)
        assert.Equal(t, 200, resp.StatusCode)

        // 2. 发送一批相似错误请求
        errorRequests := []TestRequest{
            {Method: "POST", Path: "/api/users", SimulateError: "database_connection"},
            {Method: "POST", Path: "/api/users", SimulateError: "database_connection"},
            {Method: "POST", Path: "/api/users", SimulateError: "database_connection"},
            {Method: "POST", Path: "/api/users", SimulateError: "database_connection"},
            {Method: "POST", Path: "/api/users", SimulateError: "database_connection"},
        }

        // 发送错误请求
        for _, req := range errorRequests {
            resp := testEnv.SendRequest(req.Method, req.Path+"?error="+req.SimulateError, nil)
            assert.Equal(t, 500, resp.StatusCode)
        }

        // 3. 等待聚类和策略生成 (模拟实际处理时间)
        time.Sleep(30 * time.Second)

        // 4. 验证聚类结果
        clusters, err := testEnv.GetClusters()
        assert.NoError(t, err)
        assert.Greater(t, len(clusters), 0, "应该至少有一个错误簇")

        // 5. 验证策略生效 - 后续相同错误应该被限流
        limitedCount := 0
        for i := 0; i < 20; i++ {
            resp := testEnv.SendRequest("POST", "/api/users?error=database_connection", nil)
            if resp.StatusCode == 429 { // Too Many Requests
                limitedCount++
            }
        }

        assert.Greater(t, limitedCount, 5, "应该有部分请求被限流")

        // 6. 验证监控指标
        metrics, err := testEnv.GetMetrics()
        assert.NoError(t, err)
        assert.Greater(t, metrics["gateway_requests_total"], 0)
        assert.Greater(t, metrics["gateway_rate_limit_hits_total"], 0)
    })
}

func TestCircuitBreakerFlow(t *testing.T) {
    testEnv := setupIntegrationTestEnv(t)
    defer testEnv.Cleanup()

    t.Run("熔断器流程测试", func(t *testing.T) {
        // 1. 快速发送大量错误请求触发熔断
        for i := 0; i < 50; i++ {
            testEnv.SendRequest("GET", "/api/service-down?error=service_unavailable", nil)
        }

        // 等待熔断策略生成
        time.Sleep(20 * time.Second)

        // 2. 验证熔断器状态
        stats, err := testEnv.GetClusterStats("service_unavailable_cluster")
        assert.NoError(t, err)
        assert.Equal(t, "open", stats.BreakerState) // 应该处于开启状态

        // 3. 验证熔断生效 - 请求应该快速失败
        start := time.Now()
        resp := testEnv.SendRequest("GET", "/api/service-down", nil)
        duration := time.Since(start)

        assert.Equal(t, 503, resp.StatusCode) // Service Unavailable
        assert.Less(t, duration, 100*time.Millisecond, "熔断请求应该快速失败")

        // 4. 等待恢复时间后验证半开状态
        time.Sleep(35 * time.Second) // 超过RecoveryTimeout

        stats, err = testEnv.GetClusterStats("service_unavailable_cluster")
        assert.NoError(t, err)
        assert.Equal(t, "half_open", stats.BreakerState)
    })
}
```

### 配置热更新测试

```go
func TestConfigHotReload(t *testing.T) {
    testEnv := setupIntegrationTestEnv(t)
    defer testEnv.Cleanup()

    t.Run("配置热更新", func(t *testing.T) {
        // 1. 获取初始配置
        initialConfig, err := testEnv.GetConfig()
        assert.NoError(t, err)

        // 2. 更新ETCD中的策略配置
        newPolicy := &types.Policy{
            ClusterID:   "test-cluster",
            PolicyType:  types.PolicyTypeRateLimit,
            Severity:    0.8,
            RateLimit: &types.RateLimitPolicy{
                Rate:     50,
                Capacity: 100,
            },
            CreateTime: time.Now(),
            ExpireTime: time.Now().Add(1 * time.Hour),
        }

        err = testEnv.UpdatePolicy("test-cluster", newPolicy)
        assert.NoError(t, err)

        // 3. 等待配置更新生效
        time.Sleep(5 * time.Second)

        // 4. 验证新配置已生效
        updatedConfig, err := testEnv.GetPolicy("test-cluster")
        assert.NoError(t, err)
        assert.Equal(t, newPolicy.Severity, updatedConfig.Severity)
        assert.Equal(t, newPolicy.RateLimit.Rate, updatedConfig.RateLimit.Rate)
    })
}
```

---

## ⚡ 性能测试

### 基准测试

```bash
# 1. 运行基准测试
make bench

# 2. 生成性能分析报告
go test -bench=. -benchmem -cpuprofile=cpu.prof -memprofile=mem.prof ./...

# 3. 分析性能瓶颈
go tool pprof cpu.prof
go tool pprof mem.prof
```

### 并发性能测试

```go
// test/benchmark/gateway_benchmark_test.go
func BenchmarkGatewayThroughput(b *testing.B) {
    config := &types.GatewayConfig{
        Server: types.ServerConfig{Host: "localhost", Port: 8080},
        Limiter: types.LimiterConfig{DefaultRate: 100000}, // 高限流用于测试
    }

    gateway, err := gateway.NewGateway(config)
    if err != nil {
        b.Fatal(err)
    }
    router := gateway.GetRouter()

    b.ResetTimer()
    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            w := httptest.NewRecorder()
            req := httptest.NewRequest("GET", "/api/test", nil)
            router.ServeHTTP(w, req)
        }
    })
}

func BenchmarkVectorSimilarity(b *testing.B) {
    vec1 := make([]float32, 768) // BGE模型向量维度
    vec2 := make([]float32, 768)

    // 初始化向量
    for i := range vec1 {
        vec1[i] = rand.Float32()
        vec2[i] = rand.Float32()
    }

    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        _ = utils.CosineSimilarity(vec1, vec2)
    }
}

func BenchmarkClusteringEngine(b *testing.B) {
    mockEmbedding := &MockEmbeddingService{}
    mockVectorDB := &MockVectorDB{}
    config := &types.ClusteringConfig{SimilarityThreshold: 0.8}

    engine := NewClusteringEngine(config, mockEmbedding, mockVectorDB)

    // 预填充一些簇
    for i := 0; i < 100; i++ {
        event := &types.ErrorEvent{
            EventID:      fmt.Sprintf("event-%d", i),
            ErrorMessage: fmt.Sprintf("error message %d", i%10), // 10种不同错误
        }
        engine.ProcessErrorEvent(event)
    }

    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        event := &types.ErrorEvent{
            EventID:      fmt.Sprintf("bench-event-%d", i),
            ErrorMessage: "benchmark error message",
        }
        engine.ProcessErrorEvent(event)
    }
}
```

### 压力测试

```bash
#!/bin/bash
# test/stress/stress_test.sh

echo "开始压力测试..."

# 1. 启动测试环境
make docker-compose-up
sleep 30

# 2. 正常流量压力测试
echo "=== 正常流量压力测试 ==="
wrk -t12 -c400 -d30s --script=test/stress/normal_traffic.lua http://localhost:8080/api/test

# 3. 错误流量压力测试
echo "=== 错误流量压力测试 ==="
wrk -t12 -c400 -d30s --script=test/stress/error_traffic.lua http://localhost:8080/api/test

# 4. 混合流量压力测试
echo "=== 混合流量压力测试 ==="
wrk -t12 -c400 -d60s --script=test/stress/mixed_traffic.lua http://localhost:8080/api/test

# 5. 收集性能指标
echo "=== 性能指标收集 ==="
curl -s http://localhost:8080/metrics | grep -E "(request_duration|rate_limit_hits|cluster_size)"

# 6. 清理环境
make docker-compose-down
```

### 性能验收标准

```go
// test/performance/acceptance_test.go
func TestPerformanceAcceptance(t *testing.T) {
    testEnv := setupPerformanceTestEnv(t)
    defer testEnv.Cleanup()

    t.Run("延迟增加验收", func(t *testing.T) {
        // 测试无网关直连延迟
        baselineLatency := measureDirectLatency(t, 1000)

        // 测试通过网关延迟
        gatewayLatency := measureGatewayLatency(t, 1000)

        // 验收标准：P95延迟增加≤2ms
        latencyIncrease := gatewayLatency.P95 - baselineLatency.P95
        assert.LessOrEqual(t, latencyIncrease, 2*time.Millisecond,
            "P95延迟增加应该≤2ms，实际增加了%.2fms",
            float64(latencyIncrease)/float64(time.Millisecond))
    })

    t.Run("减灾效果验收", func(t *testing.T) {
        // 模拟故障场景
        faultScenario := &FaultInjection{
            ErrorRate:    0.5, // 50%错误率
            Duration:     60 * time.Second,
            ErrorType:    "database_timeout",
        }

        // 无保护情况下的错误峰值
        baselineErrors := measureErrorsWithoutProtection(t, faultScenario)

        // 有保护情况下的错误峰值
        protectedErrors := measureErrorsWithProtection(t, faultScenario)

        // 验收标准：减灾效果≥40%
        reductionRate := (baselineErrors - protectedErrors) / baselineErrors
        assert.GreaterOrEqual(t, reductionRate, 0.4,
            "减灾效果应该≥40%%，实际为%.1f%%", reductionRate*100)
    })

    t.Run("误杀率验收", func(t *testing.T) {
        // 在限流策略生效期间发送正常请求
        totalRequests := 1000
        successfulRequests := 0
        rateLimitedRequests := 0

        for i := 0; i < totalRequests; i++ {
            resp := testEnv.SendNormalRequest()
            switch resp.StatusCode {
            case 200:
                successfulRequests++
            case 429:
                rateLimitedRequests++
                // 验证被限流的请求如果重试是否能成功
                retryResp := testEnv.RetryRequest(resp.Headers["Retry-After"])
                if retryResp.StatusCode == 200 {
                    // 这算作误杀
                }
            }
        }

        // 验收标准：误杀率≤2%
        falsePositiveRate := float64(rateLimitedRequests) / float64(totalRequests)
        assert.LessOrEqual(t, falsePositiveRate, 0.02,
            "误杀率应该≤2%%，实际为%.1f%%", falsePositiveRate*100)
    })
}
```

---

## 🏥 健康检查和监控测试

### 健康检查测试

```go
// test/health/health_test.go
func TestHealthEndpoints(t *testing.T) {
    testEnv := setupTestEnv(t)
    defer testEnv.Cleanup()

    t.Run("健康检查", func(t *testing.T) {
        resp, err := http.Get("http://localhost:8080/health")
        assert.NoError(t, err)
        assert.Equal(t, 200, resp.StatusCode)

        var health map[string]interface{}
        json.NewDecoder(resp.Body).Decode(&health)
        assert.Equal(t, "healthy", health["status"])
    })

    t.Run("就绪检查", func(t *testing.T) {
        resp, err := http.Get("http://localhost:8080/ready")
        assert.NoError(t, err)
        assert.Contains(t, []int{200, 503}, resp.StatusCode)

        var readiness map[string]interface{}
        json.NewDecoder(resp.Body).Decode(&readiness)
        assert.NotEmpty(t, readiness["components"])
    })
}
```

### 监控指标测试

```go
func TestMonitoringMetrics(t *testing.T) {
    testEnv := setupTestEnv(t)
    defer testEnv.Cleanup()

    t.Run("Prometheus指标", func(t *testing.T) {
        // 发送一些请求产生指标
        for i := 0; i < 100; i++ {
            testEnv.SendRequest("GET", "/api/test", nil)
        }

        // 获取指标
        resp, err := http.Get("http://localhost:8080/metrics")
        assert.NoError(t, err)

        body, err := io.ReadAll(resp.Body)
        assert.NoError(t, err)
        metrics := string(body)

        // 验证关键指标存在
        assert.Contains(t, metrics, "gateway_requests_total")
        assert.Contains(t, metrics, "gateway_request_duration_seconds")
        assert.Contains(t, metrics, "gateway_rate_limit_hits_total")
        assert.Contains(t, metrics, "gateway_circuit_breaker_state")
    })
}
```

---

## 📊 测试数据和场景

### 测试数据准备

```go
// test/testdata/scenarios.go
var TestScenarios = []struct {
    Name        string
    Description string
    Requests    []TestRequest
    Expected    TestExpectation
}{
    {
        Name:        "数据库连接错误聚类",
        Description: "相似的数据库连接错误应该被聚类到同一簇",
        Requests: []TestRequest{
            {Path: "/api/users", Error: "connection timeout to database"},
            {Path: "/api/orders", Error: "database connection failed"},
            {Path: "/api/products", Error: "timeout connecting to database"},
        },
        Expected: TestExpectation{
            ClusterCount:    1,
            ShouldTrigger:   true,
            PolicyType:     "rate_limit",
            ExpectedSeverity: 0.6,
        },
    },
    {
        Name:        "不同类型错误分离",
        Description: "不同类型的错误应该被分到不同簇",
        Requests: []TestRequest{
            {Path: "/api/users", Error: "database connection failed"},
            {Path: "/api/users", Error: "authentication required"},
            {Path: "/api/users", Error: "invalid request format"},
        },
        Expected: TestExpectation{
            ClusterCount:  3,
            ShouldTrigger: false,
        },
    },
}
```

### 错误注入测试

```go
// test/chaos/fault_injection_test.go
func TestFaultInjection(t *testing.T) {
    testEnv := setupChaosTestEnv(t)
    defer testEnv.Cleanup()

    faults := []ChaosTest{
        {
            Name:     "数据库故障",
            Fault:    &DatabaseDownFault{Duration: 30 * time.Second},
            Expected: &ExpectedBehavior{ShouldCircuitBreak: true},
        },
        {
            Name:     "网络延迟",
            Fault:    &NetworkLatencyFault{Latency: 5 * time.Second},
            Expected: &ExpectedBehavior{ShouldRateLimit: true},
        },
        {
            Name:     "内存不足",
            Fault:    &MemoryExhaustionFault{},
            Expected: &ExpectedBehavior{ShouldGracefullyDegrade: true},
        },
    }

    for _, fault := range faults {
        t.Run(fault.Name, func(t *testing.T) {
            // 注入故障
            testEnv.InjectFault(fault.Fault)

            // 发送流量
            results := testEnv.SendTrafficDuringFault(1000)

            // 验证预期行为
            testEnv.VerifyBehavior(results, fault.Expected)

            // 清理故障
            testEnv.ClearFault(fault.Fault)
        })
    }
}
```

---

## 🚀 测试执行流程

### 本地测试流程

```bash
#!/bin/bash
# 本地完整测试流程

echo "🚀 开始LLM-Aware Gateway测试流程"

# 1. 环境检查
echo "📋 环境检查..."
go version
docker --version
make --version

# 2. 依赖安装
echo "📦 安装依赖..."
make deps
make install-tools

# 3. 代码质量检查
echo "🔍 代码质量检查..."
make fmt
make vet
make lint

# 4. 单元测试
echo "🧪 单元测试..."
make test

# 5. 启动测试环境
echo "🐳 启动测试环境..."
make docker-compose-up
sleep 30

# 6. 健康检查
echo "💓 健康检查..."
make health-check

# 7. 集成测试
echo "🔗 集成测试..."
go test -tags=integration ./test/integration/... -v

# 8. 性能测试
echo "⚡ 性能测试..."
go test -bench=. ./test/benchmark/... -v

# 9. 压力测试
echo "💪 压力测试..."
bash test/stress/stress_test.sh

# 10. 清理环境
echo "🧹 清理环境..."
make docker-compose-down

echo "✅ 测试流程完成！"
```

### CI/CD测试流程

```yaml
# .github/workflows/test.yml
name: Test Pipeline

on: [push, pull_request]

jobs:
  unit-test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - uses: actions/setup-go@v3
      with:
        go-version: '1.21'

    - name: Run unit tests
      run: |
        make deps
        make test

    - name: Upload coverage
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.out

  integration-test:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: password
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

      etcd:
        image: quay.io/coreos/etcd:v3.5.10

    steps:
    - uses: actions/checkout@v3
    - uses: actions/setup-go@v3
      with:
        go-version: '1.21'

    - name: Start test environment
      run: make docker-compose-up

    - name: Run integration tests
      run: go test -tags=integration ./test/integration/... -v

    - name: Cleanup
      run: make docker-compose-down

  performance-test:
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
    - uses: actions/checkout@v3
    - name: Run performance tests
      run: |
        make docker-compose-up
        sleep 30
        bash test/performance/run_performance_tests.sh
        make docker-compose-down
```

---

## 📈 测试报告和分析

### 测试覆盖率要求

- **单元测试覆盖率**: ≥80%
- **集成测试覆盖率**: ≥60%
- **关键路径覆盖率**: 100%

### 性能基线

| 指标 | 目标值 | 测试方法 |
|------|--------|----------|
| P95延迟增加 | ≤2ms | 基准对比测试 |
| 吞吐量损失 | ≤5% | 压力测试 |
| 内存使用增加 | ≤50MB | 长时间运行测试 |
| CPU使用增加 | ≤10% | 负载测试 |
| 减灾效果 | ≥40% | 故障注入测试 |
| 误杀率 | ≤2% | 混合流量测试 |

### 测试报告模板

```markdown
# 测试报告

## 测试概况
- 测试时间：2024-01-15
- 测试环境：Docker Compose
- 测试版本：v1.0.0

## 测试结果摘要
- ✅ 单元测试：通过率 98%（196/200）
- ✅ 集成测试：通过率 95%（38/40）
- ✅ 性能测试：达标（P95延迟增加1.8ms）
- ⚠️ 压力测试：部分达标（需优化内存使用）

## 详细结果
### 功能测试
- 限流器：✅ 通过
- 熔断器：✅ 通过
- 聚类引擎：✅ 通过
- 配置热更新：✅ 通过

### 性能测试
- 延迟增加：1.8ms（目标≤2ms）✅
- 减灾效果：42%（目标≥40%）✅
- 误杀率：1.8%（目标≤2%）✅

## 问题和建议
1. 内存使用在高负载下超出预期，建议优化缓存策略
2. 某些边界条件下的错误处理需要完善

## 风险评估
- 低风险：核心功能稳定可靠
- 中风险：高并发场景下需要监控内存使用

## 发布建议
✅ 建议发布到生产环境，建议增加内存监控告警
```

这个测试指南涵盖了从单元测试到性能测试的完整测试策略，确保LLM-Aware Gateway的质量和可靠性。通过系统化的测试方法，可以验证系统在各种场景下的表现，为生产环境部署提供信心。
